https://software.intel.com/zh-cn/blogs/2013/10/09/javascript-this
javascript用法整理

大方向：Javascripte的this看的是究竟是l{用函式，而不是看函式被定x在哪物件龋
		@大原t抓到了，基本上就已可以探知this的W秘了。



第一种情况：this指向於{用函式之物件（有调用者）

	公式
	物件.函式(); //函式鹊this指向物件

	范例
	var  obj = {
		x: 20,
		f: function(){ console.log(this.x); }
	};

	obj.f(); //由於{用f函式r，c前面物件obj，故f鹊this指向obj，t出20。

	obj.obj = {	
		x: 30,
		f: function(){ console.log(this.x); }
	}

	obj.innerobj.f(); //由於{用f函式r，c前面物件obj.innerobj，故f鹊this指向obj.innerobj，t出30。
	
	
第二种情况：this指向全域物件(g[器：window物件、node.js：GLOBAL物件)(无调用者)

	公式
	函式(); //函式鹊this指向全域物件
	
	范例
	var x = 10;
	var f = function(){
		console.log(this.x);
	};

	f(); //由於{用f函式r，前方K未有[物件.]的形式，故f鹊this指向全域物件，t出全域档x(10)。
	
	
	前煞N情r常`Ч例:

		例一：物件之成T函式扔泻式
		var x = 10;
		var obj = {
			x: 20,
			f: function(){
				console.log(this.x);
				var foo = function(){ console.log(this.x); }
				foo(); // (2)10
			}
		};

		obj.f();  // (1)20
		
		结果：非 20，20； 而是 20，10
		解释：因(1)obj.f(){用r，f前面物件obj，故f鹊this指向obj。但因檎{用f鹊(2)foo函式r是用foo()，
			  {用的前方K未有物件，故foo鹊this指向全域物件，所以出是全域档x的值。
		
		改造：
		var x = 10;
		var obj = {
			x: 20,
			f: function(){
				console.log(this.x);
				var that = this;	//使用that保留在@函式鹊this
				var foo = function(){ console.log(that.x); }
				foo(); // (2)20
			}
		};

		obj.f();  // (1)20
		
		
		例二：借用函式
		var x = 10;
		var obj = {
			x: 20,
			f: function(){ console.log(this.x); }
		};

		obj.f(); // (1)20

		var fOut = obj.f;
		fOut(); //(2)10

		var obj2 = {
			x: 30,
			f: obj.f
		}

		obj2.f(); // (3)30
		
		结果：20 10 30
		解释：例中三次{用之函式的this所指向的物件楹危不知道各位能不能看得出怼ｋm然用的是同一函式，但是
			  因檎{用的不同，故this所指向的物件就不同。(1)obj.f()的f所指向的是obj，@比^]有}，出的是
			  20；而(2)fOut()e的this，t是因檎{用r前方o物件，tthis所指的是全域物件，出的是10；最後(3)
			  obj2.f()t是obj2去呼叫f，故f鹊this指向的是obj2，出的是30；
		
3.this指向利用call或apply所指派othis的物件
	公式
	(A物件.)函式.call(B物件,1,2,3, ......); //函式的this指向B物件(若B物件null，t指向全域物件)
	(A物件.)函式.apply(B物件,[1,2,3, ......]); //函式的this指向B物件(若B物件null，t指向全域物件)
	区别：
	call的调用方式传递参数的时候用的是普通的方式传递参数；apply的调用方式传递参数的时候用的是对象的方式传递参数。
	
	范例：
	var obj = {
		x: 20;
		f: function(){ console.log(this.x); }
	};

	var obj2 = {
		x: 30;
	};

	obj1.f.call(obj2); //利用call指派f的this橹赶obj2，故出30
	
4.this指向new所a生之新物件

	若⒑式作建式(constructor)碛茫t炔康thist指向於new所a生之新物件。

	公式
	new 建式(); //建式戎this指向new所a生之新物件
	
	例
	function Monster(){
		this.hp = 100;
	};

	var monster = new Monster(); //Monster的this指向new出碇新物件K回骰恚new的法就似於下面的法。
	var monster = (function(){
		var _new = { constructor: Monster, __proto__: Monster.prototype }; //在IE瓤赡懿幌嗨
		_new.constructor(); //@也是楹握f可以利用前三N情r碜化的原因，constructor呼叫r，this指向的即是_new@物件。
		return _new;
	})();
	
5.callback函式鹊this指向於{用放入callback的函式之this所指向之物件

	$('#button').click(function(){
		this.html("Clicked");
	})
	此r@this居然指向$(‘#button’)@物件，感X很自然，但H想想X得很神奇。假O你一function，
	它可以吃一function，K在e面呼叫魅氲function，你怎N呢？
	
	var f = function(innerf){
		//前面的理
		innerf(arg1, arg2, arg3, ......);
		//後面的理
	}
	但如果@的，innerfe的this根前述t就是全域物件了！那槭颤N常常e人作的callback函式可this
	指向於{用放入callback的函式之this所指向之物件呢？@表示大家作上遵守一t，⒆约旱this鹘ocallback
	作它的this碛茫∵@也是槭颤N我f@情r其也是前三N情r的化而已了！所以上面的code改成如下的形式
	比^好：
	
	var f = function(innerf){
		//前面的理
		innerf.call(this, arg1, arg2, arg3, ......);
		//或是innerf.apply(this, [arg1, arg2, arg3, ......])
		//後面的理
	}